<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Qcs on CIST</title>
    <link>https://vantnprof.github.io/qc/</link>
    <description>Recent content in Qcs on CIST</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 31 May 2024 01:37:55 -0500</lastBuildDate><atom:link href="https://vantnprof.github.io/qc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HHL algorithm implementation for SLE</title>
      <link>https://vantnprof.github.io/qc/hhl_example/</link>
      <pubDate>Fri, 31 May 2024 01:37:55 -0500</pubDate>
      
      <guid>https://vantnprof.github.io/qc/hhl_example/</guid>
      <description>What is the actual implementation of HHL? Input: $$ A = \begin{bmatrix} 2 &amp;amp; 1 \\ 1 &amp;amp; 2 \end{bmatrix}, b = \begin{bmatrix} \frac{1}{\sqrt{2}} &amp;amp; -\frac{1}{\sqrt{2}}\end{bmatrix} $$
Let see how we can implement HHL algorithm to solve it?
Precalculation By eigenvalue decomposition, we have:
$$ A = Q\Lambda Q^T = \begin{bmatrix}\frac{1}{\sqrt{2}} &amp;amp; \frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}} &amp;amp; -\frac{1}{\sqrt{2}} \end{bmatrix} \begin{bmatrix}1 &amp;amp; 0 \\ 0 &amp;amp; 3 \end{bmatrix} \begin{bmatrix}\frac{1}{\sqrt{2}} &amp;amp; \frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}} &amp;amp; -\frac{1}{\sqrt{2}} \end{bmatrix}^T $$ It means the eigenvectors of \(A\) are: \(q_0 = \begin{bmatrix}\frac{1}{\sqrt{2}} &amp;amp; \frac{1}{\sqrt{2}}\end{bmatrix}^T, q_1 = \begin{bmatrix}\frac{1}{\sqrt{2}} &amp;amp; -\frac{1}{\sqrt{2}}\end{bmatrix}^T\) correponsding the eigenvalues \(\lambda_0 = 1, \lambda_1 = 3\).</description>
      <content:encoded><![CDATA[<h2 id="what-is-the-actual-implementation-of-hhl">What is the actual implementation of HHL?</h2>
<p><!-- raw HTML omitted -->Input:
$$
A = \begin{bmatrix}
2 &amp; 1 \\
1 &amp; 2
\end{bmatrix}, b = \begin{bmatrix} \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}\end{bmatrix}
$$</p>
<p>Let see how we can implement HHL algorithm to solve it?</p>
<h2 id="precalculation">Precalculation</h2>
<p>By eigenvalue decomposition, we have:</p>
<p>$$
A = Q\Lambda Q^T = \begin{bmatrix}\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
\end{bmatrix} \begin{bmatrix}1 &amp; 0 \\
0 &amp; 3
\end{bmatrix} \begin{bmatrix}\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
\end{bmatrix}^T
$$
It means the eigenvectors of \(A\) are: \(q_0 = \begin{bmatrix}\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}}\end{bmatrix}^T, q_1 = \begin{bmatrix}\frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}\end{bmatrix}^T\) correponsding the eigenvalues \(\lambda_0 = 1, \lambda_1 = 3\).</p>
<p>Observation from the input:</p>
<ul>
<li>The matrix \(A\) is Hermitian, so do not need to do the agumented operation.</li>
<li>The vector \(b\) is unit vector (\(\sqrt{(\frac{1}{\sqrt{2}})^2+(-\frac{1}{2})^2}=1\)), so do not need to do the normalization.</li>
</ul>
<h3 id="how-many-qubits-need-to-be-used">How many qubits need to be used?</h3>
<p>To encode \(\lambda_0, \lambda_1\), we need to use \(n_c=2\) qubits since the maximum eigenvalue is 3 and the ratio between \(\lambda_1\) and \(\lambda_0\) is \(3/1 = 4\). It means we present these value in a Hilbert space with basics \(\ket{00}, \ket{01}, \ket{10}, \ket{11}\). This encoding is done in a register, which is called as clock-register, or c-register for short. Luckily, they are all integers and the ratio is also integer. This means the representation of those values in quantum circuit are exact itself, i.e., \(\tilde{\lambda_0} = 1, \tilde{\lambda_1} = 3\), or in other words \(\ket{\tilde{\lambda_0}}=\ket{01}\) and \(\ket{\tilde{\lambda_1}}=\ket{11}\). This give us a perfect encoding with \(n_c=2\). Therefore, \(t\) would be chosen to be \(\frac{\pi}{2}\) due to \(\tilde{\lambda_j} = 2^{n_c}\lambda_j t / 2\pi\).</p>
<p>Also, we have to spend 1 more qubit to encode \(b = \begin{bmatrix}\frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}\end{bmatrix}^T\).</p>
<p>Therefore, the total number of qubits is \(n + n_c + 1 = 1 + 2 + 1 = 4\). Noticeably, in this calculation, besides c-register and input register for \(b\), we also need anciila qubit (which is already counted) to perform rotation and partial measurement.</p>
<h3 id="matrix-encoding-u--eiat">Matrix encoding \(U = e^{iAt}\)</h3>
<p>We need to find two matrix \(U^2, U\) with \(U=e^{iAt}\). From the previous analysis, we have: \(A = Q \Lambda Q^T\), or \(\Lambda = Q^T A Q\). Supposedly, \(U = Q U_{\text{diag}} Q^{\dagger}\), then we have:
$$
U_{\text{diag}} = \begin{bmatrix}
e^{i\lambda_0t} &amp; 0 \\
0 &amp; e^{i\lambda_1t}
\end{bmatrix} = \begin{bmatrix}
e^{i \times 1 \times \frac{\pi}{2}} &amp; 0 \\
0 &amp; e^{i \times 2 \times \frac{\pi}{2}}
\end{bmatrix} = \begin{bmatrix}
i &amp; 0 \\
0 &amp; -1
\end{bmatrix}
$$
and $$
U_{\text{diag}}^2 = U_{\text{diag}} U_{\text{diag}} = \begin{bmatrix}
i &amp; 0 \\
0 &amp; -1
\end{bmatrix} \begin{bmatrix}
i &amp; 0 \\
0 &amp; -1
\end{bmatrix} = \begin{bmatrix}
-1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}
$$
Then, we transform \(U_{\text{diag}}, U_{\text{diag}}^2\) back to \(U, U^2\) by:
$$
U = Q U_{\text{diag}}Q^{\dagger} =  \begin{bmatrix}\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
\end{bmatrix} \begin{bmatrix}
i &amp; 0 \\
0 &amp; -1
\end{bmatrix} \begin{bmatrix}\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}
\end{bmatrix}^T =\frac{1}{2} \begin{bmatrix}i - 1&amp; i + 1 \\
i + 1 &amp; i - 1
\end{bmatrix}
$$</p>
<p>$$
U^2 = \frac{1}{4} \begin{bmatrix}i - 1&amp; i + 1 \\
i + 1 &amp; i - 1
\end{bmatrix} \begin{bmatrix}i - 1&amp; i + 1 \\
i + 1 &amp; i - 1
\end{bmatrix} = \begin{bmatrix}0 &amp; -1 \\
-1 &amp; 0
\end{bmatrix}
$$</p>
<p>For quantum implementation of these operators, a 4-parameter arbitrary unitary gate is utilized:
$$
G = \begin{bmatrix}
e^{i \gamma} \cos{(\theta/2)} &amp; -e^{i(\gamma + \lambda)}\sin{(\theta/2)} \\
e^{i(\gamma + \phi)}\sin{(\theta/2)} &amp; e^{i(\gamma + \phi + \lambda)}\cos{(\theta/2)}
\end{bmatrix}
$$
It means, to implement \(U\) into quantum circuit, we have to find/define a tuple of four parameters \((\theta, \phi, \lambda, \gamma)\) such that:</p>
<p>$$
\begin{cases}
\frac{1}{2}(i-1) = e^{i\gamma } \cos{(\theta/2)} \\
\frac{1}{2}(i+1) = -e^{i(\gamma + \lambda)}\sin{(\theta/2)} \\
\frac{1}{2}(i+1) = e^{i(\gamma + \phi)}\sin{(\theta/2)} \\
\frac{1}{2}(i-1) = e^{i(\gamma + \phi + \lambda)}\cos{(\theta/2)} \\
\end{cases}
$$
So now we have \(4\) euqations and \(4\) unknowns!</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Quantum algorithm for system of linear equations</title>
      <link>https://vantnprof.github.io/qc/hhl/</link>
      <pubDate>Thu, 30 May 2024 14:35:17 -0500</pubDate>
      
      <guid>https://vantnprof.github.io/qc/hhl/</guid>
      <description>System of linear equations The most well-known problems in linear algebera that people educated in school is system of linear equations, aka SLE. The simple one is:
$$ 2x_0 + 3 = 0 $$
Or multiple linear equations like below.
$$ \begin{cases} x_0 + x_1 = -1 \\ 3x_0 + x_1 = 10 \end{cases} $$
In linear algebra, we can form the problem under matrix presentation: $$ Ax = b $$ with $$ \mathbb{R}^{N \times D} \ni A = \begin{bmatrix} a_{0,0} &amp;amp; \dots &amp;amp; a_{0, D-1} \\ \vdots &amp;amp; \ddots &amp;amp; \vdots \\ a_{N-1, 0} &amp;amp; \dots &amp;amp; a_{N-1, D-1} \end{bmatrix}, b = \begin{bmatrix} b_0 \\ \vdots \\ b_{N-1} \end{bmatrix} \in \mathbb{R}^{N} $$ and the goal is to find vector \(x = [x_0, \dots, x_{D-1}]\) given \(A, b\).</description>
      <content:encoded><![CDATA[<h2 id="system-of-linear-equations">System of linear equations</h2>
<p>The most well-known problems in linear algebera that people educated in school is system of linear equations, aka SLE. The simple one is:</p>
<p>$$
2x_0 + 3 = 0
$$</p>
<p>Or multiple linear equations like below.</p>
<p>$$
\begin{cases}
x_0 + x_1 = -1 \\
3x_0 + x_1 = 10
\end{cases}
$$</p>
<p>In linear algebra, we can form the problem under matrix presentation:
$$
Ax = b
$$
with
$$
\mathbb{R}^{N \times D} \ni A = \begin{bmatrix}
a_{0,0} &amp;  \dots &amp; a_{0, D-1} \\
\vdots &amp; \ddots &amp; \vdots \\
a_{N-1, 0} &amp; \dots &amp; a_{N-1, D-1}
\end{bmatrix},
b = \begin{bmatrix}
b_0 \\
\vdots \\
b_{N-1}
\end{bmatrix} \in \mathbb{R}^{N}
$$
and the goal is to find vector \(x = [x_0, \dots, x_{D-1}]\) given \(A, b\).
For example, the above problem can be modeled as:
$$
\begin{bmatrix}
1 &amp; 1 \\
3 &amp; 10
\end{bmatrix} \begin{bmatrix} x_0 \\ x_1\end{bmatrix} = \begin{bmatrix}-1 \\ 10\end{bmatrix}
$$. In this cae, \(A = \begin{bmatrix}
1 &amp; 1 \\
3 &amp; 10
\end{bmatrix}\) and \(\begin{bmatrix}-1 \\ 10\end{bmatrix}\).</p>
<h2 id="in-school-teach-algorithms">In-school teach algorithms</h2>
<p>The most common way to solve the system of linear equation we usually know is the substitution. For example to solve the problem above, from the first equation, we have \(y = -1 - x\), then we plug it into the second euqation:
$$
3x + 10(-1 - x) = 10 \\
\Rightarrow x = -\frac{20}{7}
$$
then we have \(y = - 1 - x = \frac{13}{7}\). Therefore, the solution of given system is \((\frac{-20}{7}, \frac{13}{7})\).</p>
<p>Under point of view of linear algebera, the solution vector \(x\) can be found by multiplying the inverse of \(A\) with vector \(b\).
$$
x = A^{-1} b
$$
, with \(A^{-1}\) denotes for the inverse operator. Of course, to do it, \(A\) must be a square matrix, and invertible. It means exists a matrix \(C\) such that \(CA = I\), with \(I\) is an identity matrix.</p>
<p>Now we talk about the way we can find the inverse of \(A\). In college, we would be educated a method call Gaussian-Jordan elimination which iteratively standarlize the original matrix to identity matrix and at the end we get the inverse. For example, to find the inverse of abovementioned matrix, we write the original matrix as an expansion version below.</p>
<p>$$
\begin{pmatrix}
1 &amp; 1  &amp;\bigm| &amp;1 &amp; 0 \\
3 &amp; 10 &amp;\bigm| &amp;0 &amp; 1 \\
\end{pmatrix} \rightarrow \begin{pmatrix}
1 &amp; 0 &amp;\bigm| &amp;10/7 &amp;  -1/7\\
0 &amp; 1 &amp;\bigm| &amp;-3/7 &amp; 1/7 \\
\end{pmatrix}
$$
So we have the inverse matrix is \(\begin{bmatrix} 10/7 &amp;  -1/7\\
-3/7 &amp; 1/7\end{bmatrix}\)
Then, by simply multiplying it with vector \(b\), we get the solution:
$$
x  = \begin{bmatrix} 10/7 &amp;  -1/7\\
-3/7 &amp; 1/7\end{bmatrix}\begin{bmatrix}-1 \\ 10\end{bmatrix} = \begin{bmatrix}-20/7 \\ 13/7 \end{bmatrix}
$$</p>
<p>About the complexity, GJ requires an amount of running time is an order of \(\mathcal{O}(N^3)\) while the total memory need to be allocated is order of \(\mathcal{O}(n^2)\)</p>
<h2 id="any-faster-methods">Any faster methods?</h2>
<p>Under the development of quantum computing, which is expected to replace the classical computation with many merits. In that, exponential speed up ability is the main advantage of quantum property compared with classical computers. For example, the fastest method to solve SLE, in classic, which is conjugate gradient requiring \(\mathcal{O}(m\sqrt{k})\), where \(m\) is the number of non-zero entries and \(k\) is the condition number.</p>
<p>However, quantum hardware can beat the limit of classic! In 2009, three research scientists including Aram W. Harrow, Avinatan Hassisdim, Seth Lloyd presented a quantum algorithm for SLE. The most successfull merit of their paper is their method only requires a \(poly(\log{N},k)\) in term of speeed, which is expentential improvement compared with the best classical algorithm.</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
